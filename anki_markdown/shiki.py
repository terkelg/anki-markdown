"""Shiki language and theme management for Anki Markdown.

Downloads language grammars and themes from esm.sh and manages them
in collection.media for mobile sync.
"""

from pathlib import Path
import urllib.request
import ssl
import json
import re

ADDON_DIR = Path(__file__).parent
ESM_BASE = "https://esm.sh/@shikijs"
SHIKI_VERSION = "3.22.0"

# Generated by scripts/generate.ts
AVAILABLE_LANGS = [
    "1c", "1c-query", "abap", "actionscript-3", "ada", "adoc", "angular-html",
    "angular-ts", "apache", "apex", "apl", "applescript", "ara", "asciidoc",
    "asm", "astro", "awk", "ballerina", "bash", "bat", "batch", "be",
    "beancount", "berry", "bibtex", "bicep", "blade", "bsl", "c", "c#", "c++",
    "c3", "cadence", "cairo", "cdc", "cjs", "clarity", "clj", "clojure",
    "closure-templates", "cmake", "cmd", "cobol", "codeowners", "codeql",
    "coffee", "coffeescript", "common-lisp", "console", "coq", "cpp", "cql",
    "crystal", "cs", "csharp", "css", "csv", "cts", "cue", "cypher", "d",
    "dart", "dax", "desktop", "diff", "docker", "dockerfile", "dotenv",
    "dream-maker", "edge", "elisp", "elixir", "elm", "emacs-lisp", "erb",
    "erl", "erlang", "f", "f#", "f03", "f08", "f18", "f77", "f90", "f95",
    "fennel", "fish", "fluent", "for", "fortran-fixed-form",
    "fortran-free-form", "fs", "fsharp", "fsl", "ftl", "gd", "gdresource",
    "gdscript", "gdshader", "genie", "gherkin", "git-commit", "git-rebase",
    "gjs", "gleam", "glimmer-js", "glimmer-ts", "glsl", "gn", "gnuplot", "go",
    "gql", "graphql", "groovy", "gts", "hack", "haml", "handlebars", "haskell",
    "haxe", "hbs", "hcl", "hjson", "hlsl", "hs", "html", "html-derivative",
    "http", "hurl", "hxml", "hy", "imba", "ini", "jade", "java", "javascript",
    "jinja", "jison", "jl", "js", "json", "json5", "jsonc", "jsonl", "jsonnet",
    "jssm", "jsx", "julia", "kdl", "kotlin", "kql", "kt", "kts", "kusto",
    "latex", "lean", "lean4", "less", "liquid", "lisp", "lit", "llvm", "log",
    "logo", "lua", "luau", "make", "makefile", "markdown", "marko", "matlab",
    "mbt", "mbti", "md", "mdc", "mdx", "mediawiki", "mermaid", "mips",
    "mipsasm", "mjs", "mmd", "mojo", "moonbit", "move", "mts", "nar", "narrat",
    "nextflow", "nf", "nginx", "nim", "nix", "nu", "nushell", "objc",
    "objective-c", "objective-cpp", "ocaml", "odin", "openscad", "pascal",
    "perl", "perl6", "php", "pkl", "plsql", "po", "polar", "postcss", "pot",
    "potx", "powerquery", "powershell", "prisma", "prolog", "properties",
    "proto", "protobuf", "ps", "ps1", "pug", "puppet", "purescript", "py",
    "python", "ql", "qml", "qmldir", "qss", "r", "racket", "raku", "razor",
    "rb", "reg", "regex", "regexp", "rel", "riscv", "ron", "rosmsg", "rs",
    "rst", "ruby", "rust", "sas", "sass", "scad", "scala", "scheme", "scss",
    "sdbl", "sh", "shader", "shaderlab", "shell", "shellscript",
    "shellsession", "smalltalk", "solidity", "soy", "sparql", "spl", "splunk",
    "sql", "ssh-config", "stata", "styl", "stylus", "surql", "surrealql",
    "svelte", "swift", "system-verilog", "systemd", "talon", "talonscript",
    "tasl", "tcl", "templ", "terraform", "tex", "tf", "tfvars", "toml", "tres",
    "ts", "ts-tags", "tscn", "tsp", "tsv", "tsx", "turtle", "twig", "typ",
    "typescript", "typespec", "typst", "v", "vala", "vb", "verilog", "vhdl",
    "vim", "viml", "vimscript", "vue", "vue-html", "vue-vine", "vy", "vyper",
    "wasm", "wenyan", "wgsl", "wiki", "wikitext", "wit", "wl", "wolfram",
    "xml", "xsl", "yaml", "yml", "zenscript", "zig", "zsh", "文言",
]

AVAILABLE_THEMES = [
    "andromeeda", "aurora-x", "ayu-dark", "ayu-light", "ayu-mirage",
    "catppuccin-frappe", "catppuccin-latte", "catppuccin-macchiato",
    "catppuccin-mocha", "dark-plus", "dracula", "dracula-soft",
    "everforest-dark", "everforest-light", "github-dark",
    "github-dark-default", "github-dark-dimmed", "github-dark-high-contrast",
    "github-light", "github-light-default", "github-light-high-contrast",
    "gruvbox-dark-hard", "gruvbox-dark-medium", "gruvbox-dark-soft",
    "gruvbox-light-hard", "gruvbox-light-medium", "gruvbox-light-soft",
    "horizon", "houston", "kanagawa-dragon", "kanagawa-lotus", "kanagawa-wave",
    "laserwave", "light-plus", "material-theme", "material-theme-darker",
    "material-theme-lighter", "material-theme-ocean",
    "material-theme-palenight", "min-dark", "min-light", "monokai",
    "night-owl", "night-owl-light", "nord", "one-dark-pro", "one-light",
    "plastic", "poimandres", "red", "rose-pine", "rose-pine-dawn",
    "rose-pine-moon", "slack-dark", "slack-ochin", "snazzy-light",
    "solarized-dark", "solarized-light", "synthwave-84", "tokyo-night",
    "vesper", "vitesse-black", "vitesse-dark", "vitesse-light",
]


# Pure functions

_IMPORT_RE = re.compile(r"""from\s*["']\./([^"'.]+)\.mjs["']""")

def esm_url(kind: str, name: str, version: str) -> str:
    """Generate esm.sh URL for a language or theme module."""
    pkg = "langs" if kind == "lang" else "themes"
    return f"{ESM_BASE}/{pkg}@{version}/es2022/{name}.mjs"


def is_alias_module(content: bytes) -> str | None:
    """Check if module is an alias (re-export from another module).
    Returns the canonical name if it's an alias, None otherwise.
    """
    text = content.decode("utf-8")
    if len(text) < 200:
        match = _IMPORT_RE.search(text)
        if match:
            return match.group(1)
    return None


def lang_deps(content: str) -> list[str]:
    """Extract language dependency names from module content."""
    return _IMPORT_RE.findall(content)


def rewrite_lang_imports(content: str) -> str:
    """Rewrite relative .mjs imports to local _lang-*.js paths."""
    return _IMPORT_RE.sub(
        lambda m: f'from"./_lang-{m.group(1)}.js"',
        content,
    )


# I/O

def fetch_module(url: str) -> bytes:
    """Fetch module content from esm.sh."""
    ctx = ssl.create_default_context()
    req = urllib.request.Request(url, headers={"User-Agent": "AnkiMarkdown/1.0"})
    with urllib.request.urlopen(req, timeout=30, context=ctx) as resp:
        return resp.read()


# Store

class ShikiStore:
    def __init__(self, dir: Path, version: str = SHIKI_VERSION):
        self.dir = dir
        self.version = version

    def download_lang(self, name: str, _seen: set[str] | None = None):
        """Download a language grammar, resolving aliases and deps."""
        if _seen is None:
            _seen = set()
        if name in _seen:
            return
        _seen.add(name)

        raw = fetch_module(esm_url("lang", name, self.version))

        canonical = is_alias_module(raw)
        if canonical:
            raw = fetch_module(esm_url("lang", canonical, self.version))

        text = raw.decode("utf-8")
        deps = lang_deps(text)
        text = rewrite_lang_imports(text)

        (self.dir / f"_lang-{name}.js").write_text(text, encoding="utf-8")

        for dep in deps:
            self.download_lang(dep, _seen)

    def download_theme(self, name: str):
        """Download a theme and save to store directory."""
        raw = fetch_module(esm_url("theme", name, self.version))
        (self.dir / f"_theme-{name}.js").write_bytes(raw)

    def needs_redownload(self, name: str) -> bool:
        """Check if a language file is missing or has unrewritten imports."""
        path = self.dir / f"_lang-{name}.js"
        if not path.exists():
            return True
        text = path.read_text(encoding="utf-8")
        return bool(_IMPORT_RE.search(text))

    def local_langs(self) -> set[str]:
        """Get set of language names that exist locally."""
        return {f.stem.removeprefix("_lang-") for f in self.dir.glob("_lang-*.js")}

    def local_themes(self) -> set[str]:
        """Get set of theme names that exist locally."""
        return {f.stem.removeprefix("_theme-") for f in self.dir.glob("_theme-*.js")}

    def collect_deps(self) -> set[str]:
        """Collect all dependency names referenced by local lang files."""
        deps = set()
        for f in self.dir.glob("_lang-*.js"):
            text = f.read_text(encoding="utf-8")
            deps.update(re.findall(r'from"\.\/_lang-([^.]+)\.js"', text))
        return deps

    def cleanup(self, config: dict) -> list[str]:
        """Remove unused language/theme files. Returns removed filenames."""
        removed = []
        keep = set(config.get("languages", [])) | self.collect_deps()
        themes = {config["themes"]["light"], config["themes"]["dark"]}

        for f in self.dir.glob("_lang-*.js"):
            name = f.stem.removeprefix("_lang-")
            if name not in keep:
                f.unlink()
                removed.append(f.name)

        for f in self.dir.glob("_theme-*.js"):
            name = f.stem.removeprefix("_theme-")
            if name not in themes:
                f.unlink()
                removed.append(f.name)

        return removed

    def sync(self, config: dict) -> tuple[list[str], list[str]]:
        """Download missing/broken languages and themes.

        Returns (downloaded, errors) lists.
        """
        downloaded = []
        errors = []

        for lang in config.get("languages", []):
            if self.needs_redownload(lang):
                try:
                    self.download_lang(lang)
                    downloaded.append(f"_lang-{lang}.js")
                except Exception as e:
                    errors.append(f"Failed to download {lang}: {e}")

        for theme in [config["themes"]["light"], config["themes"]["dark"]]:
            if not (self.dir / f"_theme-{theme}.js").exists():
                try:
                    self.download_theme(theme)
                    downloaded.append(f"_theme-{theme}.js")
                except Exception as e:
                    errors.append(f"Failed to download theme {theme}: {e}")

        return downloaded, errors


# Default instance
store = ShikiStore(ADDON_DIR)


# Anki glue (lazy-import aqt)

def get_config() -> dict:
    """Get add-on config, falling back to defaults."""
    from aqt import mw
    config = mw.addonManager.getConfig(__name__.split(".")[0])
    if config is None:
        config = {
            "languages": ["javascript", "typescript", "python", "html", "css", "json", "bash", "markdown", "glsl", "wgsl", "rust", "swift", "go"],
            "themes": {"light": "vitesse-light", "dark": "vitesse-dark"},
            "cardless": False,
        }
    return config


def generate_config_json() -> str:
    """Generate JSON config string for embedding in templates."""
    config = get_config()
    return json.dumps({
        "languages": config.get("languages", []),
        "themes": config.get("themes", {}),
        "cardless": config.get("cardless", False),
    }, separators=(",", ":"))
